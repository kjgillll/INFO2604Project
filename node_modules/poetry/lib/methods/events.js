var DB = require( '../db/query.js' );
var Log = require( '../methods/log' );
var ifcs = require( 'os' )
    .networkInterfaces();
var service = 'unknown service',
    address = '';

try {
    var pkg = require( process.cwd() + '/package.json' );
    service = pkg.name || service;
} catch ( e ) {}

try {
    address = ifcs.eth0[ 0 ].address;
} catch ( e ) {}

var watchers = [];
var interval = 1000;

module.exports.services = [service];

module.exports.on = function on( eventName, pattern, cb ) {
    if ( !pattern ) pattern = {};

    DB( 'poetry_checked', 'find' )({
        _id: service + '~' + eventName,
    }).then(last => {
        watchers.push( {
            eventName: eventName,
            pattern: pattern,
            cb: cb,
            lastWatch: last.last || new Date()
        } );
    });
};

module.exports.emit = function emit( eventName, message ) {
    try {
        DB( 'poetry_events', 'insert' )( {
                name: eventName,
                message: [ message ],
                service: service,
                address: address
            } )
            .then( function ( ev ) {
                if (ev) Log.verbose( 'ðŸ“¤  Event emited:', eventName, '(' + ev._id.toString() + ')' );
            }, () => {} );
    } catch ( e ) {
        Log.warn( 'Event not emited: ', eventName );
        Log.error( e );
    }
};

function watcher( watch, i ) {
    DB( 'poetry_events', 'find' )( {
            name: watch.eventName,
            createdAt: {
                $gt: watch.lastWatch
            }
        } )
        .sort( {
            _id: 1
        } )
        .then( function ( events ) {
            // console.log('CHECK EVENTS', watch, events.length);
            if ( !events || !events.length ) return;
            events.forEach( e => {
                Log.verbose( 'ðŸ“¥  Event from ' + e.service + ' :', e.name, ' (', e._id.toString(), ')' );
                process.nextTick(() => watch.cb( e.message[ 0 ], {
                    name: e.service,
                    address: e.address,
                    timestamp: e.createdAt,
                    uuid: e._id
                } ));
                if(!~module.exports.services.indexOf(e.service))
                    module.exports.services.push(e.service);
            } );
            watchers[ i ].lastWatch = events[ events.length - 1 ].createdAt;
            DB( 'poetry_checked', 'update' )( {
                _id: service + '~' + watch.eventName,
            },{
                $set: {
                    last: events[ events.length - 1 ].createdAt,
                }
            }, {
                upsert: true,
            }).then(() => {});

        }, ( e ) => {
            Log.error( 'FATAL ERROR retrieving events' );
            Log.error( e );
            process.exit();
        } );
}

setInterval(() => watchers.forEach(watcher), interval);
