const Models = require( '../../models' ),
    Log = require( './log' ),
    Bcrypt = require( 'bcrypt' );

const Users = Models.users,
    Teams = Models.teams,
    Sessions = Models.sessions,
    Logs = Models.logs,
    ApiKeys = Models.ApiKeys;


module.exports = function login( email, password, isMobile, host, path ) {

    email = email.toLowerCase();

    return new Promise( ( resolve, reject ) => {

        if ( !~email.indexOf( '.' ) && email.length == 24 ) getAPIKey();
        else getUsers();

        function getAPIKey() {
            Log.silly( 'APIKEY', email );
            ApiKeys.findOne( {
                    _id: Models.ObjectId( email )
                } )
                .then( apikey => {
                    if ( !apikey ) return reject( 'Wrong authentication' );
                    Users.findOne( {
                            _id: Models.ObjectId( apikey.user ),
                            status: {
                                $in: [ 'active', 'new', 'apionly' ]
                            }
                        } )
                        .then( user => populateUser(user, apikey.secret, true), reject );
                }, reject );
        }

        function getUsers() {
            Users.findOne( {
                    email: email,
                    status: {
                        $in: [ 'active', 'new' ]
                    }
                } )
                .then( user => {
                    if ( !user ) return reject( "Wrong authentication" );

                    if ( !user.password )
                        return reject( "No password set" );
                    populateUser( user, user.password );
                }, reject );
        }

        function populateUser( user, pwd, maybeUnencrypted ) {
            // If there is no user
            Log.silly( 'ğŸ‘¤  User', user.email );
            checkPWD( user, pwd, maybeUnencrypted );
        };

        function checkPWD( user, pwd, maybeUnencrypted ) {

            if(maybeUnencrypted && pwd === password)
                return newSession(user);

            // Check password
            if ( !Bcrypt.compareSync( password, pwd ) )
                return reject( "Wrong authentication" );

            newSession( user );
        }

        function newSession( user ) {

            // Cleaning user
            delete user.password;
            user._id = user._id.toString();

            // Define new session
            let id = ( Math.random() * 0xFFFFFFFFFFFFFF )
                .toString( 32 );
            id += '107F4C70RY';
            id += ( Math.random() * 0xFFFFFFFFFFFFFE )
                .toString( 32 );
            let session = {
                _id: id,
                isAuthenticated: true,
                user: user
            };

            // If there's no team, resolve
            if ( user.team ) getTeam( session );
            else resolve( session );

        }


        function getTeam( session ) {
            Teams.findOne( {
                    _id: session.user.team
                } )
                .then( team => {
                    session.team = team;
                    checkMobileToken( session.user, team, session )
                        .then( () => populateTeam( session ) );
                }, reject );
        }

        function populateTeam( session ) {
            let userId = session.user._id;
            try {
                userId = Models.ObjectID( userId );
            } catch ( e ) {}

            let roleId = session.user.role;
            try {
                roleId = Models.ObjectID( roleId );
            } catch ( e ) {}

            let logsData = {
                user: userId,
                method: "post",
                path: path,
                params: {},
                team: session.user.team,
                role: roleId
            }

            // Log the authentication access in the DB :
            // because not going through 'onPreAuth' server extension function
            // =>so insert logs here
            Logs.insert( logsData )
                .then( () => {} );

            resolve( session );
        }
    } );

    function checkMobileToken( user, team, session ) {

        Log.silly( 'Login checkMobileToken' );

        return new Promise( ( resolve, reject ) => {
            if ( !( team && team.maxUsers && team.maxUsers > 0 ) ) {
                return resolve( session );
            }

            if ( !isMobile ) {
                Log.silly( 'NOT A MOBILE' );
                Sessions.remove( {
                        user: user._id,
                        $or: [ {
                                isMobile: {
                                    $exists: false
                                }
                            },
                            {
                                isMobile: {
                                    $ne: true
                                }
                            }
                        ]
                    } )
                    .then(
                        res => {
                            Log.silly( 'Removed old session' );
                            resolve( session );
                        },
                        err => {
                            Log.error( err );
                            resolve( session );
                        }
                    );
            } else {
                Log.silly( 'A MOBILE IT IS' );
                session.isMobile = true;
                if ( user.mobileToken ) {
                    Log.silly( 'A MOBILE TOKEN already exists' );
                    return reject( "You are already connected" );
                }

                let userId;
                try {
                    userId = Models.ObjectID( user._id );
                } catch ( e ) {
                    userId = user._id;
                }

                Users.findAndModify( {
                        query: {
                            _id: userId
                        },
                        update: {
                            '$set': {
                                mobileToken: session._id
                            }
                        },
                        new: true
                    } )
                    .then( userUpdated => {
                        if ( !userUpdated ) {
                            Log.debug( 'Error updating USER mobileToken' );
                            return reject( 'Error updating USER mobileToken' );
                        }
                        Log.debug( '$set mobileToken' );
                        userUpdated._id = userUpdated._id.toString();
                        session.user = userUpdated;
                        resolve( session );
                    } )
                    .catch( err => {
                        Log.debug( err );
                        return reject( err );
                    } );
            }
        } );

    }

};
