const Log = require( '../methods/log' ),
    Search = require( './Search' ),
    dbConnection = require( './connection' ),
    AggrMethods = require( './AggrMethods' );

/**
 * Aggregation
 * Sugar aggregation builder, through chained methods.
 * @param {Model} modelORM Promised-mongo collection object
 * @return {Promise}
 */
module.exports = function Aggregation( collection ) {

    // Create an array
    let aggregation = [];

    // Link methods
    AggrMethods.forEach( verb => {
        aggregation[ verb ] = wraper( verb );
    } );

    // Wrap into a verb
    function wraper( verb ) {
        return ( param ) => {

            // Wrap in the $verb
            let step = {};
            step[ '$' + verb ] = param;

            // Add to aggregation and chain
            aggregation.push( step );
            return aggregation;

        };
    }

    // Execute aggregation when CB is set
    aggregation.then = function ( success, failed ) {

        let prom = new Promise( ( resolve, reject ) => {

            dbConnection( collection )
                .then( db => {

                    if ( !db.aggregate )
                        return Log.error( 'Aggregation not available on', collection );

                    // Pass the pipeline, the Callbacks and return the Promise
                    return db.aggregate( aggregation, {
                        allowDiskUse: true
                    }, ( err, result ) => {
                        if ( err ) reject( err );
                        else resolve( result );
                    } );

                }, reject);

        } );

        if ( success ) {
            if ( failed )
                prom.then( success, failed );
            else
                prom.then( success );
        }

        return prom;

    };

    // Add a search sugar builder
    aggregation.search = function ( needle, fields ) {
        if ( !needle ) return aggregation;
        return aggregation.match( Search( needle, fields ) );
    };

    aggregation.populateBy = function () {
      return aggregation
          .lookup({
              from: 'users',
              foreignField: '_id',
              localField: 'createdBy',
              as: '_createdBy'
          })
          .unwind({
              path: '$_createdBy',
              preserveNullAndEmptyArrays: true
          })
          .lookup({
              from: 'users',
              foreignField: '_id',
              localField: 'updatedBy',
              as: '_updatedBy'
          })
          .unwind({
              path: '$_updatedBy',
              preserveNullAndEmptyArrays: true
          })
          .addFields({
            createdBy: {
              $cond:{
                if: { $ne : ['$_createdBy', undefined] },
                then: {
                  _id: '$_createdBy._id',
                  firstName: '$_createdBy.firstName',
                  lastName: '$_createdBy.lastName',
                },
                else: undefined
              }
            },
            updatedBy: {
              $cond:{
                if: { $ne : ['$_updatedBy', undefined] },
                then: {
                  _id: '$_updatedBy._id',
                  firstName: '$_updatedBy.firstName',
                  lastName: '$_updatedBy.lastName',
                },
                else: undefined
              }
            },
          })
          .project({
            _createdBy: 0,
            _updatedBy: 0,
          });
    };

    // Return the aggregation array/builder
    return aggregation;

};
